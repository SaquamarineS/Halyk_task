import cv2
import numpy as np

def order_points(pts):
    """Упорядочивает координаты четырех точек.

    Инициализирует список координат, который будет упорядочен
    так, чтобы первая запись в списке была верхним левым углом,
    вторая - верхним правым, третья - нижним правым и четвертая -
    нижним левым углом.

    Параметры
    ----------
    pts : numpy ndarray
        Массив размером 4x2, содержащий координаты 4 точек.

    Returns
    -------
    numpy ndarray
        Массив размером 4x2, содержащий упорядоченные координаты 4 точек.
    """
    rect = np.zeros((4, 2), dtype="float32")

    # Точка верхнего левого угла будет иметь наименьшую сумму координат,
    # а точка нижнего правого угла - наибольшую сумму координат
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]

    # Теперь вычислим разницу между точками, точка верхнего правого угла
    # будет иметь наименьшую разницу координат, а точка нижнего левого угла -
    # наибольшую разницу
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]
    rect[3] = pts[np.argmax(diff)]

    # Возвращаем упорядоченные координаты
    return rect


def four_point_transform(image, pts):
    """Перестраивает изображение для получения обзора сверху.

    Параметры
    ----------
    image : numpy ndarray
        Входное изображение.
    pts : numpy ndarray
        Массив размером 4x2, содержащий координаты 4 точек, необходимых
        для восстановления изображения.

    Returns
    -------
    numpy ndarray
        Восстановленное изображение.
    """
    # Получаем однородный набор координат точек и их отдельные значения
    rect = order_points(pts)
    (tl, tr, br, bl) = rect

    # Вычисляем ширину нового изображения, которая будет максимальным
    # расстоянием между правой и левой нижних точками или правой и левой
    # верхними точками
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))

    # Вычисляем высоту нового изображения, которая будет максимальным
    # расстоянием между правой верхней и правой нижней точками или левой
    # верхней и левой нижней точками
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))

    # Теперь, когда мы знаем размеры нового изображения, строим набор
    # точек назначения, чтобы получить вид "сверху" изображения,
    # указывая точки в порядке верхний левый, верхний правый,
    # нижний правый и нижний левый угол
    dst = np.array([
        [0, 0],
        [maxWidth - 1, 0],
        [maxWidth - 1, maxHeight - 1],
        [0, maxHeight - 1]], dtype="float32")

    # Вычисляем матрицу преобразования перспективы и применяем ее
    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))

    # Возвращаем перестроенное изображение
    return warped
